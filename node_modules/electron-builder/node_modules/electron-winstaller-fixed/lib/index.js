'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWindowsInstaller = exports.fileExists = undefined;

var _bluebird = require('bluebird');

let fileExists = exports.fileExists = (() => {
  var ref = (0, _bluebird.coroutine)(function* (file) {
    try {
      return (yield (0, _fsExtraP.stat)(file)).isFile();
    } catch (err) {
      log(err);
    }

    return false;
  });
  return function fileExists(_x) {
    return ref.apply(this, arguments);
  };
})();

let computeMetadata = (() => {
  var ref = (0, _bluebird.coroutine)(function* (options) {
    const metadata = {
      description: '',
      iconUrl: 'https://raw.githubusercontent.com/atom/electron/master/atom/browser/resources/win/atom.ico'
    };

    if (options.usePackageJson !== false) {
      const appResources = _path2.default.join(options.appDirectory, 'resources');
      const asarFile = _path2.default.join(appResources, 'app.asar');
      let appMetadata;

      if (yield fileExists(asarFile)) {
        appMetadata = JSON.parse(_asar2.default.extractFile(asarFile, 'package.json'));
      } else {
        appMetadata = JSON.parse((yield (0, _fsExtraP.readFile)(_path2.default.join(appResources, 'app', 'package.json'), 'utf8')));
      }

      Object.assign(metadata, {
        exe: `${ appMetadata.name }.exe`,
        title: appMetadata.productName || appMetadata.name
      }, appMetadata);
    }

    Object.assign(metadata, options);
    if (metadata.authors == null) {
      if (typeof metadata.author === 'string') {
        metadata.authors = metadata.author;
      } else {
        metadata.authors = (metadata.author || {}).name || '';
      }
    }
    return metadata;
  });
  return function computeMetadata(_x2) {
    return ref.apply(this, arguments);
  };
})();

let copyUpdateExe = (() => {
  var ref = (0, _bluebird.coroutine)(function* (appUpdate, options, rcEditOptions, baseSignOptions) {
    yield (0, _fsExtraP.copy)(vendor('Update.exe'), appUpdate);
    if (options.setupIcon && options.skipUpdateIcon !== true) {
      yield rcedit(appUpdate, rcEditOptions);
    }
    yield signFile(appUpdate, baseSignOptions);
  });
  return function copyUpdateExe(_x3, _x4, _x5, _x6) {
    return ref.apply(this, arguments);
  };
})();

let createWindowsInstaller = exports.createWindowsInstaller = (() => {
  var ref = (0, _bluebird.coroutine)(function* (options) {
    const rcEditOptions = Object.assign({}, options.rcedit, {
      icon: options.setupIcon
    });
    const rcVersionString = rcEditOptions['version-string'];
    if (rcVersionString != null && rcVersionString.LegalCopyright != null) {
      // rcedit cannot set © symbol (or windows bug?), replace to safe
      rcVersionString.LegalCopyright = rcVersionString.LegalCopyright.replace('©', '(C)');
    }

    const metadata = yield computeMetadata(options);
    const baseSignOptions = options.certificateFile && options.certificatePassword ? Object.assign({
      cert: options.certificateFile,
      password: options.certificatePassword,
      name: metadata.title,
      overwrite: true
    }, options.sign) : null;

    const appUpdate = _path2.default.join(options.appDirectory, 'Update.exe');
    const outputDirectory = _path2.default.resolve(options.outputDirectory || 'installer');
    const promises = [copyUpdateExe(appUpdate, options, rcEditOptions, baseSignOptions), (0, _fsExtraP.mkdirs)(outputDirectory)];
    if (options.remoteReleases) {
      promises.push(syncReleases(outputDirectory, options));
    }
    yield _bluebird.Promise.all(promises);

    const embeddedArchiveFile = _path2.default.join(outputDirectory, 'setup.zip');
    const embeddedArchive = (0, _archiver2.default)('zip');
    const embeddedArchiveOut = (0, _fsExtraP.createWriteStream)(embeddedArchiveFile);
    const embeddedArchivePromise = new _bluebird.Promise(function (resolve, reject) {
      embeddedArchive.on('error', reject);
      embeddedArchiveOut.on('close', resolve);
    });
    embeddedArchive.pipe(embeddedArchiveOut);

    embeddedArchive.file(appUpdate, { name: 'Update.exe' });
    embeddedArchive.file(options.loadingGif ? _path2.default.resolve(options.loadingGif) : _path2.default.join(__dirname, '..', 'resources', 'install-spinner.gif'), { name: 'background.gif' });

    const version = convertVersion(metadata.version);
    const packageName = `${ metadata.name }-${ version }-full.nupkg`;
    const nupkgPath = _path2.default.join(outputDirectory, packageName);
    const setupPath = _path2.default.join(outputDirectory, options.setupExe || `${ metadata.name || metadata.productName }Setup.exe`);

    yield _bluebird.Promise.all([pack(metadata, options.appDirectory, nupkgPath, version, options.packageCompressionLevel), (0, _fsExtraP.copy)(vendor('Setup.exe'), setupPath)]);

    embeddedArchive.file(nupkgPath, { name: packageName });

    const releaseEntry = yield releasify(nupkgPath, outputDirectory);

    embeddedArchive.append(releaseEntry, { name: 'RELEASES' });
    embeddedArchive.finalize();
    yield embeddedArchivePromise;

    yield writeZipToSetup(setupPath, embeddedArchiveFile);
    yield _bluebird.Promise.all([rcedit(setupPath, rcEditOptions), (0, _fsExtraP.remove)(embeddedArchiveFile)]);

    yield signFile(setupPath, baseSignOptions);
    if (options.msi && process.platform === 'win32') {
      yield msi(nupkgPath, setupPath);
      yield signFile(_path2.default.join(outputDirectory, 'Setup.msi'), baseSignOptions);
      if (options.fixUpPaths !== false && metadata.productName) {
        yield (0, _fsExtraP.rename)(_path2.default.join(outputDirectory, 'Setup.msi'), _path2.default.join(outputDirectory, `${ metadata.productName }Setup.msi`));
      }
    }
  });
  return function createWindowsInstaller(_x7) {
    return ref.apply(this, arguments);
  };
})();

let pack = (() => {
  var ref = (0, _bluebird.coroutine)(function* (metadata, directory, outFile, version, packageCompressionLevel) {
    const archive = (0, _archiver2.default)('zip', { zlib: { level: packageCompressionLevel == null ? 9 : packageCompressionLevel } });
    // const archiveOut = createWriteStream('/Users/develar/test.zip')
    const archiveOut = (0, _fsExtraP.createWriteStream)(outFile);
    const archivePromise = new _bluebird.Promise(function (resolve, reject) {
      archive.on('error', reject);
      archiveOut.on('close', resolve);
    });
    archive.pipe(archiveOut);

    const author = metadata.authors || metadata.owners;
    const copyright = metadata.copyright || `Copyright © ${ new Date().getFullYear() } ${ author }`;
    const nuspecContent = `<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
  <metadata>
    <id>${ metadata.name }</id>
    <version>${ version }</version>
    <title>${ metadata.title }</title>
    <authors>${ author }</authors>
    <owners>${ metadata.owners || metadata.authors }</owners>
    <iconUrl>${ metadata.iconUrl }</iconUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>${ metadata.description }</description>
    <copyright>${ copyright }</copyright>${ metadata.extraMetadataSpecs || '' }
  </metadata>
</package>`;
    log(`Created NuSpec file:\n${ nuspecContent }`);
    archive.append(nuspecContent.replace(/\n/, '\r\n'), { name: `${ encodeURI(metadata.name).replace(/%5B/g, '[').replace(/%5D/g, ']') }.nuspec` });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Type="http://schemas.microsoft.com/packaging/2010/07/manifest" Target="/${ metadata.name }.nuspec" Id="Re0" />
  <Relationship Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="/package/services/metadata/core-properties/1.psmdcp" Id="Re1" />
</Relationships>`.replace(/\n/, '\r\n'), { name: '.rels', prefix: '_rels' });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="nuspec" ContentType="application/octet" />
  <Default Extension="pak" ContentType="application/octet" />
  <Default Extension="asar" ContentType="application/octet" />
  <Default Extension="bin" ContentType="application/octet" />
  <Default Extension="dll" ContentType="application/octet" />
  <Default Extension="exe" ContentType="application/octet" />
  <Default Extension="dat" ContentType="application/octet" />
  <Default Extension="psmdcp" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
  <Override PartName="/lib/net45/LICENSE" ContentType="application/octet" />
  <Default Extension="diff" ContentType="application/octet" />
  <Default Extension="bsdiff" ContentType="application/octet" />
  <Default Extension="shasum" ContentType="text/plain" />
</Types>`.replace(/\n/, '\r\n'), { name: '[Content_Types].xml' });

    archive.append(`<?xml version="1.0" encoding="utf-8"?>
<coreProperties xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns="http://schemas.openxmlformats.org/package/2006/metadata/core-properties">
  <dc:creator>${ author }</dc:creator>
  <dc:description>${ metadata.description }</dc:description>
  <dc:identifier>${ metadata.name }</dc:identifier>
  <version>${ version }</version>
  <keywords/>
  <dc:title>${ metadata.title }</dc:title>
  <lastModifiedBy>NuGet, Version=2.8.50926.602, Culture=neutral, PublicKeyToken=null;Microsoft Windows NT 6.2.9200.0;.NET Framework 4</lastModifiedBy>
</coreProperties>`.replace(/\n/, '\r\n'), { name: '1.psmdcp', prefix: 'package/services/metadata/core-properties' });

    encodedZip(archive, directory, 'lib/net45');
    yield archivePromise;
  });
  return function pack(_x8, _x9, _x10, _x11, _x12) {
    return ref.apply(this, arguments);
  };
})();

let releasify = (() => {
  var ref = (0, _bluebird.coroutine)(function* (nupkgPath, outputDirectory) {
    const args = ['--releasify', nupkgPath, '--releaseDir', outputDirectory];
    const out = (yield (0, _spawnPromise.exec)(process.platform === 'win32' ? vendor('Update.com') : 'mono', prepareArgs(args, vendor('Update-Mono.exe')))).trim();
    const last = out.lastIndexOf('\n');
    if (last > 0) {
      console.log(out.substring(0, last + 1));
    }
    return last > 0 ? out.substring(last + 1) : out;
  });
  return function releasify(_x13, _x14) {
    return ref.apply(this, arguments);
  };
})();

exports.convertVersion = convertVersion;

var _spawnPromise = require('./spawn-promise');

var _asar = require('asar');

var _asar2 = _interopRequireDefault(_asar);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _signcodeTf = require('signcode-tf');

var _archiver = require('archiver');

var _archiver2 = _interopRequireDefault(_archiver);

var _fsExtraP = require('fs-extra-p');

var _archiverUtils = require('archiver-utils');

var _archiverUtils2 = _interopRequireDefault(_archiverUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rcedit = _bluebird.Promise.promisify(require('rcedit'));
const log = require('debug')('electron-windows-installer');
const sign = _bluebird.Promise.promisify(_signcodeTf.sign);

function convertVersion(version) {
  const parts = version.split('-');
  const mainVersion = parts.shift();

  if (parts.length > 0) {
    return [mainVersion, parts.join('-').replace(/\./g, '')].join('-');
  } else {
    return mainVersion;
  }
}

function syncReleases(outputDirectory, options) {
  const args = prepareArgs(['-u', options.remoteReleases, '-r', outputDirectory], vendor('SyncReleases.exe'));
  if (options.remoteToken) {
    args.push('-t', options.remoteToken);
  }
  return (0, _spawnPromise.spawn)(process.platform === 'win32' ? vendor('SyncReleases.exe') : 'mono', args);
}

function signFile(file, baseSignOptions) {
  if (baseSignOptions != null && process.platform !== 'linux') {
    const signOptions = Object.assign({}, baseSignOptions);
    signOptions.path = file;
    return sign(signOptions);
  }
  return _bluebird.Promise.resolve();
}

function msi(nupkgPath, setupPath) {
  const args = ['--createMsi', nupkgPath, '--bootstrapperExe', setupPath];
  return (0, _spawnPromise.spawn)(process.platform === 'win32' ? vendor('Update.com') : 'mono', prepareArgs(args, vendor('Update-Mono.exe')));
}

function writeZipToSetup(setupExe, zipFile) {
  const exePath = vendor('WriteZipToSetup.exe');
  return (0, _spawnPromise.exec)(process.platform === 'win32' ? exePath : 'wine', prepareArgs([setupExe, zipFile], exePath));
}

function prepareArgs(args, exePath) {
  if (process.platform !== 'win32') {
    args.unshift(exePath);
  }
  return args;
}

function vendor(executable) {
  return _path2.default.join(__dirname, '..', 'vendor', executable);
}

function encodedZip(archive, dir, prefix) {
  _archiverUtils2.default.walkdir(dir, function (error, files) {
    if (error) {
      archive.emit('error', error);
      return;
    }

    for (let file of files) {
      if (file.stats.isDirectory()) {
        continue;
      }

      // GBK file name encoding (or Non-English file name) caused a problem
      const entryData = {
        name: encodeURI(file.relative.replace(/\\/g, '/')).replace(/%5B/g, '[').replace(/%5D/g, ']'),
        prefix: prefix,
        stats: file.stats
      };
      archive._append(file.path, entryData);
    }

    archive.finalize();
  });
}